'''
Approach:
- start dfs from an infected node, explore all uninfected parts --> count the number of nodes in it. Finally add and get the maximum nodes saved by removing an infected node.

Several mistakes made in this problem.
- Was using just one visited array. But soon discovered that a node might be connected to another infected node and stop. While other not directly connected to the infected part would still be tracked. --> Use and infected array to mark components as infected.
- While backtracking, instead of marking the current node 'i' as infected, I marked j as infected. 
'''
class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        n = len(graph)
        initial.sort()
        infected = [0] * n
        for i in initial: infected[i] = 1

        def dfs(i, count, visited):
            if infected[i]: return False
            visited.add(i)
            count[0] += 1
            for j in range(n):
                if graph[i][j] and j not in visited:
                    if not dfs(j, count, visited): 
                        infected[i] = 1
                        return False
            return True

        m, remove = 0, initial[0]
        for i in initial:
            sz = 0
            visited = set([i])
            for j in range(n):
                if graph[i][j] and j not in visited:
                    count = [0]
                    if dfs(j, count, visited):
                        sz += count[0]
            if sz > m:
                m = sz
                remove = i

        return remove